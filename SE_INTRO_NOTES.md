## บทบาทของวิศวกรซอฟต์แวร์ (Software Engineer Role)

บทบาทหลักของวิศวกรซอฟต์แวร์ (Software Engineer) คือการประยุกต์ใช้หลักการทางวิศวกรรมในการออกแบบ, พัฒนา, ทดสอบ, และบำรุงรักษาแอปพลิเคชันหรือระบบซอฟต์แวร์ เพื่อแก้ไขปัญหาในโลกแห่งความเป็นจริงและตอบสนองความต้องการของผู้ใช้งาน 
และดูแลซอฟต์แวร์ให้ทำงานตามความต้องการของผู้ใช้งานและธุรกิจ ตั้งแต่การวิเคราะห์ปัญหา วางสถาปัตยกรรม เขียนโค้ด ไปจนถึงการทดสอบและบำรุงรักษาระบบ นอกจากนี้ยังต้องทำงานร่วมกับหลายฝ่ายเพื่อให้ซอฟต์แวร์มีคุณภาพ 

### ตัวอย่างงาน/กิจกรรมที่ทำ

#### 1) Fullstack Developer

* ออกแบบและพัฒนาทั้ง Frontend และ Backend
* ทำงานกับ API, Database และ UI
* แก้ไขบั๊กในทุกส่วนของระบบ
* ทำ code review ให้เพื่อนร่วมทีม
* ประสานงานกับ SA และ Frontend เพื่อเชื่อมงานให้สมบูรณ์

#### 2) Frontend Developer

* พัฒนา UI ด้วย React/HTML/CSS/JavaScript
* ทำให้หน้าเว็บใช้งานง่าย ตรงตาม UX/UI
* เชื่อมต่อ API กับ backend
* แก้ไข visual bug และปรับ performance ฝั่ง client
* ทำงานร่วมกับ Fullstack และ SA เพื่อให้ data flow ถูกต้อง

#### 3) Backend Developer

* พัฒนา API, ระบบหลังบ้าน, business logic
* ดูแลฐานข้อมูลและ query ให้มีประสิทธิภาพ
* แก้ไขบั๊กฝั่ง server และเพิ่มความปลอดภัยของระบบ
* ทำงานร่วมกับ Frontend เพื่อส่งข้อมูลที่ถูกต้อง
* เขียนเอกสารระบบที่เกี่ยวกับ backendกับทีมอื่น เช่น design, QA, product, operations

#### 4) System Analyst (SA)

* เก็บและวิเคราะห์ requirement
* ออกแบบโครงสร้างระบบ, ER diagram, API spec

### บทบาทอื่นในทีมพัฒนา

* **QA Engineer** – ทดสอบคุณภาพระบบ ตรวจหาบั๊ก และตรวจสอบว่างานตรงตาม requirement
* **DevOps Engineer** – ดูแลการ deploy, CI/CD, server, cloud system และการทำ automation
* **UX/UI Designer** – ออกแบบประสบการณ์ผู้ใช้ (UX) และหน้าตาอินเทอร์เฟซ (UI)
* **System Analyst (SA)** – วิเคราะห์ระบบ ออกแบบโครงสร้าง
* **Fullstack Developer** – พัฒนาได้ทั้งฝั่ง Frontend และ Backend ดูภาพรวมของระบบ
* **Backend Developer** – พัฒนา logic ฝั่งเซิร์ฟเวอร์ ดูแลฐานข้อมูล และระบบหลังบ้านให้ทำงานมีประสิทธิภาพ
* **Frontend Developer** – พัฒนา UI/UX และโค้ดฝั่งผู้ใช้งาน เช่น React, HTML/CSS, JavaScript


# ภาพรวม SDLC (Software Development Life Cycle)
    ```mermaid
flowchart LR
    R[Requirements] --> D[Design]
    D --> I[Implementation]
    I --> T[Testing]
    T --> DEP[Deployment]
    DEP --> M[Maintenance]
```

### Requirements
 - เป็นขั้นตอนรวบรวมและวิเคราะห์ความต้องการของผู้ใช้และผู้มีส่วนเกี่ยวข้องทั้งหมด เพื่อให้เข้าใจว่าระบบต้องทำอะไร มีข้อจำกัดอะไร และมีเป้าหมายแบบใด

### Design
 - นำความต้องการมาจัดทำสถาปัตยกรรมระบบ โครงสร้างฐานข้อมูล และ UI/UX เบื้องต้น เพื่อกำหนดว่าแต่ละส่วนของระบบจะทำงานร่วมกันอย่างไร

### Implementation
 - นักพัฒนาจะนำแบบที่ออกแบบไว้มาเขียนโค้ดจริง แบ่งเป็นโมดูลตามฟีเจอร์ต่าง ๆ เป็นขั้นที่เปลี่ยนแบบจำลองให้กลายเป็นซอฟต์แวร์ที่ใช้งานได้

### Testing
 - ตรวจสอบหาข้อผิดพลาดหรือbugsของcodeและระบบ และทดสอบความถูกต้องของฟังก์ชันทั้งหมด เพื่อให้มั่นใจว่าระบบทำงานตามความต้องการและมีคุณภาพเพียงพอ

### Deployment
 - นำซอฟต์แวร์ไปติดตั้งบนเซิร์ฟเวอร์จริงหรือส่งมอบให้ผู้ใช้ใช้งาน อาจมีกระบวนการ rollout, training หรือ migration ข้อมูลร่วมด้วย

### Maintenance
 - แก้ไขปัญหาที่เกิดขึ้นหลังใช้งานจริง และอัปเดตระบบตามความต้องการที่เปลี่ยนไป เป็นขั้นตอนต่อเนื่องเพื่อให้ระบบทำงานได้ดีในระยะยาว

# Waterfall vs Agile – ตารางเปรียบเทียบ

| คุณลักษณะ        | Waterfall                  | Agile (Scrum/Kanban)            |
|-----------------|:--------------------------:|:-------------------------------:|
| โครงสร้าง         | ทำงานแบบขั้นตอนเรียงลำดับ      | ทำงานแบบวนซ้ำเป็นสปรินต์           |
| ความยืดหยุ่น       | มีความยืดหยุ่นต่ำ เปลี่ยนแปลงยาก  | มีความยืดหยุ่นสูง ปรับตามฟีดแบ็กได้    |
| การวางแผน        | วางแผนล่วงหน้าทั้งหมด          | วางแผนเป็นรอบ ๆ ตาม Sprint       |
| ฟีดแบ็กลูกค้า       | รับ Feedback ตอนท้าย         | รับ Feedback ต่อเนื่องระหว่างพัฒนา    |
| การส่งมอบ         | ส่งทีเดียวตอนจบ               | ส่งเป็นส่วน ๆ (increments)         |
| เหมาะสำหรับ       | งานที่กำหนดชัดเจน ไม่เปลี่ยนแปลง | งานที่เปลี่ยนแปลงบ่อย หรือไม่ชัดเจน    |

### การประยุกต์ใช้กับ Term Project ของกลุ่มเรา

### 1) ถ้า Term Project ใช้ Waterfall 100% กลุ่มเราคิดว่าจุดเด่น/ข้อจำกัดคืออะไร? (อย่างน้อย 3 ข้อ)
**ตอบ**
- จุดเด่น
    - โครงสร้างงานชัดเจน รู้ล่วงหน้าว่าต้องทำอะไรลำดับไหน ทำให้วางแผนทรัพยากรและเวลาได้ง่าย
    - เอกสารครบถ้วน เพราะต้องวางแผนเยอะตั้งแต่ต้น ทำให้รายละเอียดระบบและ requirement ไม่ตกหล่น
    - เหมาะกับงานที่นิ่ง ถ้า scope โครงงานของเราชัดเจนตั้งแต่แรก การใช้ Waterfall จะทำให้งานไม่หลุดขอบเขต
- ข้อจำกัด
    - ปรับเปลี่ยนยาก ถ้าอาจารย์เปลี่ยน requirement กลางทาง จะกระทบหลายส่วน ต้องแก้เอกสารและโครงสร้างงานใหม่
    - เห็นผลลัพธ์ช้า งานจะเสร็จช่วงท้าย ทำให้ทดสอบจริงและรับฟีดแบ็กได้ช้า
    - เสี่ยงงานไม่เสร็จทัน ถ้าพลาดขั้นตอนใดขั้นตอนหนึ่ง งานถัดไปจะติดค้างไปหมด เพราะต้องทำตามลำดับขั้น

### 2) ถ้า Term Project ใช้ Agile (แบ่งเป็น Sprints) จุดเด่น/ข้อจำกัดคืออะไร? (อย่างน้อย 3 ข้อ)
**ตอบ**
- จุดเด่น
    - ปรับตัวได้เร็ว ถ้าอาจารย์ให้ฟีดแบ็กหรือแก้ไขกลางทาง กลุ่มสามารถปรับใน Sprint ถัดไปได้ทันที
    - เห็นงานเป็นช่วงๆ ทำให้ทดสอบ prototype ได้เร็วกว่า ลดความเสี่ยงที่งานไม่เป็นไปตามที่อาจารย์ต้องการ
    - ทำงานเป็นทีมได้ดี ทุกคนมี task แยกกันตาม sprint board ทำให้รู้ว่าใครต้องทำอะไร และติดปัญหาตรงไหน
- ข้อจำกัด
    - ต้องจัดการเวลาในแต่ละ Sprint ให้ดี ถ้าวาง Sprint ไม่ดี งานอาจล้นหรือกระจายไม่เท่ากัน
    - ต้องประชุมและสื่อสารบ่อย ถ้าทีมไม่ active จะทำให้ Agile ทำงานไม่ได้
    - เอกสารอาจน้อยกว่าวิธีดั้งเดิม ถ้าไม่คุมดีอาจทำให้ข้อมูลกระจัดกระจายเพราะเน้น deliver เร็ว

### 3) สุดท้าย กลุ่มเราอยากใช้ approach แบบไหน หรือ hybrid แบบใด? เพราะเหตุใด? 
**ตอบ** 
hybrid รูปแบบ Waterfall + Agile เพราะ คิดว่าจะใช้ Waterfall ทำงานช่วงแรกเพื่อ เพื่อกำหนด requirement, กำหนด scope, และออกแบบระบบอย่างคร่าว ๆ ให้ทีมเข้าใจตรงกัน จากนั้นจะใช้ Agile ในช่วงพัฒนา โดยแบ่งงานเป็น Sprints เช่น 1–2 สัปดาห์ เพื่อให้ทำงานเป็นส่วน ๆ และรับ feedback จากอาจารย์ได้บ่อย โดยคิดว่าการทำแบบนี้น่าจะทำให้ ลดความเสี่ยงงานไม่เสร็จ เพราะมี deliverable ทุกสัปดาห์ ทำให้เห็นความก้าวหน้าชัดเจน และ มีความยืดหยุ่น หาก requirement เปลี่ยน เราก็ปรับใน Sprint แทนที่จะต้องรื้อใหม่ทั้งหมด

---
